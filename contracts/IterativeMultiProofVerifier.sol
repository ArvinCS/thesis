// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title IterativeMultiProofVerifier
 * @author Your Name (Universitas Indonesia)
 * @notice Verifies multiproofs for a custom unbalanced Merkle tree by
 * iteratively validating each individual leaf's proof against the root.
 * This is the on-chain component for the hierarchical, traffic-aware
 * Merkle tree structure.
 */
library IterativeMultiProofVerifier {

    /**
     * @dev A struct to hold the complete proof path for a single leaf
     * from the leaf node all the way up to the global root.
     * This data is generated by the off-chain builder.
     */
    struct LeafProof {
        bytes32 leaf;
        bytes32[] proof;
        uint8[] positions; // 0 indicates the sibling is on the left, 1 on the right.
    }

    /**
     * @notice Verifies that a set of leaves are all valid parts of a Merkle tree.
     * @param root The global Merkle root of the entire tree.
     * @param proofs An array of LeafProof structs, one for each leaf to verify.
     * @return A boolean indicating if ALL leaf proofs were successfully verified.
     */
    function verify(
        bytes32 root,
        LeafProof[] memory proofs
    ) internal pure returns (bool) {
        // Loop through each individual proof provided in the multiproof bundle.
        for (uint i = 0; i < proofs.length; i++) {
            // Re-compute the root from this single leaf's proof path.
            bytes32 computedRoot = _computeRootFromPath(proofs[i]);
            
            // If any single proof does not lead to the correct global root,
            // then the entire multiproof is considered invalid.
            if (computedRoot != root) {
                return false;
            }
        }

        // If all proofs were successfully verified against the same root,
        // the multiproof is valid.
        return true;
    }

    /**
     * @dev An internal helper function that computes the root from a single proof path.
     * This is the core logic that walks up the custom, unbalanced tree.
     * @param p A single LeafProof struct.
     * @return The computed Merkle root for that path.
     */
    function _computeRootFromPath(LeafProof memory p) private pure returns (bytes32) {
        bytes32 computedHash = p.leaf;

        require(p.proof.length == p.positions.length, "Invalid proof format");

        for (uint i = 0; i < p.proof.length; i++) {
            bytes32 proofElement = p.proof[i];
            
            if (p.positions[i] == 0) {
                // Sibling is on the left: hash(sibling, current)
                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
            } else {
                // Sibling is on the right: hash(current, sibling)
                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
            }
        }

        return computedHash;
    }
}